{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{581:function(a,e,r){\"use strict\";r.r(e);var n=r(17),t=Object(n.a)({},(function(){var a=this,e=a.$createElement,r=a._self._c||e;return r(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":a.$parent.slotKey}},[r(\"h2\",{attrs:{id:\"threadlocal源码分析\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#threadlocal源码分析\"}},[a._v(\"#\")]),a._v(\" ThreadLocal源码分析\")]),a._v(\" \"),r(\"p\",[a._v(\"当多线程访问共享可变数据时，涉及到线程间同步的问题，并不是所有时候，都要用到共享数据，所以就需要线程封闭出场了。\")]),a._v(\" \"),r(\"p\",[a._v(\"数据都被封闭在各自的线程之中，就不需要同步，这种通过将数据封闭在线程中而避免使用同步的技术称为线程封闭。\")]),a._v(\" \"),r(\"p\",[a._v(\"本文主要介绍线程封闭中的其中一种体现：ThreadLocal，将会介绍什么是 ThreadLocal；从 ThreadLocal 源码角度分析，最后介绍 ThreadLocal 的应用场景。\")]),a._v(\" \"),r(\"h3\",{attrs:{id:\"什么是-threadlocal\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#什么是-threadlocal\"}},[a._v(\"#\")]),a._v(\" 什么是 ThreadLocal？\")]),a._v(\" \"),r(\"p\",[a._v(\"ThreadLocal 是 Java 里一种特殊变量，它是一个线程级别变量，每个线程都有一个 ThreadLocal 就是每个线程都拥有了自己独立的一个变量，竞态条件被彻底消除了，在并发模式下是绝对安全的变量。\")]),a._v(\" \"),r(\"p\",[a._v(\"可以通过 ThreadLocal\"),r(\"T\",[a._v(\" value = new ThreadLocal\"),r(\"T\",[a._v(\"(); 来使用。\")])],1)],1),a._v(\" \"),r(\"p\",[a._v(\"会自动在每一个线程上创建一个 T 的副本，副本之间彼此独立，互不影响，可以用 ThreadLocal 存储一些参数，以便在线程中多个方法中使用，用以代替方法传参的做法。\")]),a._v(\" \"),r(\"p\",[a._v(\"下面通过例子来了解下 ThreadLocal：\")]),a._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",[r(\"code\",[a._v('public class ThreadLocalDemo {\\n    /**\\n     * ThreadLocal变量，每个线程都有一个副本，互不干扰\\n     */\\n    public static final ThreadLocal<String> THREAD_LOCAL = new ThreadLocal<>();\\n\\n    public static void main(String[] args) throws Exception {\\n        new ThreadLocalDemo().threadLocalTest();\\n    }\\n\\n    public void threadLocalTest() throws Exception {\\n        // 主线程设置值\\n        THREAD_LOCAL.set(\"wupx\");\\n        String v = THREAD_LOCAL.get();\\n        System.out.println(\"Thread-0线程执行之前，\" + Thread.currentThread().getName() + \"线程取到的值：\" + v);\\n\\n        new Thread(new Runnable() {\\n            @Override\\n            public void run() {\\n                String v = THREAD_LOCAL.get();\\n                System.out.println(Thread.currentThread().getName() + \"线程取到的值：\" + v);\\n                // 设置 threadLocal\\n                THREAD_LOCAL.set(\"huxy\");\\n                v = THREAD_LOCAL.get();\\n                System.out.println(\"重新设置之后，\" + Thread.currentThread().getName() + \"线程取到的值为：\" + v);\\n                System.out.println(Thread.currentThread().getName() + \"线程执行结束\");\\n            }\\n        }).start();\\n        // 等待所有线程执行结束\\n        Thread.sleep(3000L);\\n        v = THREAD_LOCAL.get();\\n        System.out.println(\"Thread-0线程执行之后，\" + Thread.currentThread().getName() + \"线程取到的值：\" + v);\\n    }\\n}\\n')])])]),r(\"p\",[a._v(\"首先通过 static final 定义了一个 THREAD_LOCAL 变量，其中 static 是为了确保全局只有一个保存 String 对象的 ThreadLocal 实例；final 确保 ThreadLocal 的实例不可更改，防止被意外改变，导致放入的值和取出来的不一致，另外还能防止 ThreadLocal 的内存泄漏。上面的例子是演示在不同的线程中获取它会得到不同的结果，运行结果如下：\")]),a._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",[r(\"code\",[a._v(\"Thread-0线程执行之前，main线程取到的值：wupx\\nThread-0线程取到的值：null\\n重新设置之后Thread-0线程取到的值为：huxy\\nThread-0线程执行结束\\nThread-0线程执行之后，main线程取到的值：wupx\\n首先在 Thread-0 线程执行之前，先给 THREAD_LOCAL 设置为 wupx，然后可以取到这个值，然后通过创建一个新的线程以后去取这个值，发现新线程取到的为 null，意外着这个变量在不同线程中取到的值是不同的，不同线程之间对于 ThreadLocal 会有对应的副本，接着在线程 Thread-0 中执行对 THREAD_LOCAL 的修改，将值改为 huxy，可以发现线程 Thread-0 获取的值变为了 huxy，主线程依然会读取到属于它的副本数据 wupx，这就是线程的封闭。\\n\")])])]),r(\"p\",[a._v(\"看到这里，我相信大家一定会好奇 ThreadLocal 是如何做到多个线程对同一对象 set 操作，但是 get 获取的值还都是每个线程 set 的值呢，接下来就让我们进入源码解析环节：\")]),a._v(\" \"),r(\"h3\",{attrs:{id:\"threadlocal-源码解析\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#threadlocal-源码解析\"}},[a._v(\"#\")]),a._v(\" ThreadLocal 源码解析\")]),a._v(\" \"),r(\"p\",[a._v(\"首先看下 ThreadLocal 都有哪些重要属性：\")]),a._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",[r(\"code\",[a._v(\"// 当前 ThreadLocal 的 hashCode，由 nextHashCode() 计算而来，用于计算当前 ThreadLocal 在 ThreadLocalMap 中的索引位置\\nprivate final int threadLocalHashCode = nextHashCode();\\n\\n// 哈希魔数，主要与斐波那契散列法以及黄金分割有关\\nprivate static final int HASH_INCREMENT = 0x61c88647;\\n\\n// 返回计算出的下一个哈希值，其值为 i * HASH_INCREMENT，其中 i 代表调用次数\\nprivate static int nextHashCode() {\\n    return nextHashCode.getAndAdd(HASH_INCREMENT);\\n}\\n\\n// 保证了在一台机器中每个 ThreadLocal 的 threadLocalHashCode 是唯一的\\nprivate static AtomicInteger nextHashCode = new AtomicInteger();\\n\")])])]),r(\"p\",[a._v(\"其中的 HASH_INCREMENT 也不是随便取的，它转化为十进制是 1640531527，2654435769 转换成 int 类型就是 -1640531527，2654435769 等于 (√5-1)/2 乘以 2 的 32 次方。(√5-1)/2 就是黄金分割数，近似为 0.618，也就是说 0x61c88647 理解为一个黄金分割数乘以 2 的 32 次方，它可以保证 nextHashCode 生成的哈希值，均匀的分布在 2 的幂次方上，且小于 2 的 32 次方。\\n下面是 javaspecialists 中一篇文章对它的介绍：\")]),a._v(\" \"),r(\"blockquote\",[r(\"p\",[a._v(\"This number represents the golden ratio (sqrt(5)-1) times two to the power of 31 ((sqrt(5)-1) * (2^31)). The result is then a golden number, either 2654435769 or -1640531527.\")])]),a._v(\" \"),r(\"p\",[a._v(\"下面用例子来证明下：\")]),a._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",[r(\"code\",[a._v('private static final int HASH_INCREMENT = 0x61c88647;\\n\\npublic static void main(String[] args) throws Exception {\\n    int n = 5;\\n    int max = 2 << (n - 1);\\n    for (int i = 0; i < max; i++) {\\n        System.out.print(i * HASH_INCREMENT & (max - 1));\\n        System.out.print(\" \");\\n\\n    }\\n}\\n')])])]),r(\"p\",[a._v(\"运行结果为：\"),r(\"code\",[a._v(\"0 7 14 21 28 3 10 17 24 31 6 13 20 27 2 9 16 23 30 5 12 19 26 1 8 15 22 29 4 11 18 25\")]),a._v(\"\\n可以发现元素索引值完美的散列在数组当中，并没有出现冲突。\")]),a._v(\" \"),r(\"h3\",{attrs:{id:\"threadlocalmap\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#threadlocalmap\"}},[a._v(\"#\")]),a._v(\" ThreadLocalMap\")]),a._v(\" \"),r(\"p\",[a._v(\"除了上述属性外，还有一个重要的属性 ThreadLocalMap，ThreadLocalMap 是 ThreadLocal 的静态内部类，当一个线程有多个 ThreadLocal 时，需要一个容器来管理多个 ThreadLocal，ThreadLocalMap 的作用就是管理线程中多个 ThreadLocal，源码如下：\")]),a._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",[r(\"code\",[a._v(\"static class ThreadLocalMap {\\n    /**\\n     * 键值对实体的存储结构\\n     * \\n     * ThreadLocalMap内部维护了一个Entry数组，Key为ThreadLocal的引用指向ThreadLocal，Value为ThreadLocal中设置的值\\n     * ThreadLocalMap是ThreadLocal的一个静态内部类，对Threadlocal的操作都会到ThreadLocalMap中实现\\n     * Thread内部也维护了一个ThreadLocals成员变量，指向ThreadLocal.ThreadLocalMap\\n     */\\n    static class Entry extends WeakReference<ThreadLocal<?>> {\\n        // 当前线程关联的 value，这个 value 并没有用弱引用追踪\\n        Object value;\\n\\n        /**\\n         * 构造键值对\\n         *\\n         * @param k k 作 key,作为 key 的 ThreadLocal 会被包装为一个弱引用\\n         * @param v v 作 value\\n         */\\n        Entry(ThreadLocal<?> k, Object v) {\\n            super(k);\\n            value = v;\\n        }\\n    }\\n\\n    // 初始容量，必须为 2 的幂\\n    private static final int INITIAL_CAPACITY = 16;\\n\\n    // 存储 ThreadLocal 的键值对实体数组，长度必须为 2 的幂\\n    private Entry[] table;\\n\\n    // ThreadLocalMap 元素数量\\n    private int size = 0;\\n\\n    // 扩容的阈值，默认是数组大小的三分之二\\n    private int threshold;\\n}\\n\")])])]),r(\"p\",[a._v(\"从源码中看到 ThreadLocalMap 其实就是一个简单的 Map 结构，底层是数组，有初始化大小，也有扩容阈值大小，数组的元素是 Entry，Entry 的 key 就是 ThreadLocal 的引用，value 是 ThreadLocal 的值。ThreadLocalMap 解决 hash 冲突的方式采用的是线性探测法，如果发生冲突会继续寻找下一个空的位置。\\n这样的就有可能会发生内存泄漏的问题，下面让我们进行分析!\")]),a._v(\" \"),r(\"h3\",{attrs:{id:\"threadlocal-内存泄漏\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#threadlocal-内存泄漏\"}},[a._v(\"#\")]),a._v(\" ThreadLocal 内存泄漏#\")]),a._v(\" \"),r(\"p\",[a._v(\"ThreadLocal 在没有外部强引用时，发生 GC 时会被回收，那么 ThreadLocalMap 中保存的 key 值就变成了 null，而 Entry 又被 threadLocalMap 对象引用，threadLocalMap 对象又被 Thread 对象所引用，那么当 Thread 一直不终结的话，value 对象就会一直存在于内存中，也就导致了内存泄漏，直至 Thread 被销毁后，才会被回收。\\n那么如何避免内存泄漏呢？\\n在使用完 ThreadLocal 变量后，需要我们手动 remove 掉，防止 ThreadLocalMap 中 Entry 一直保持对 value 的强引用，导致 value 不能被回收，其中 remove 源码如下所示：\")]),a._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",[r(\"code\",[a._v(\"/**\\n * 清理当前 ThreadLocal 对象关联的键值对\\n */\\npublic void remove() {\\n    // 返回当前线程持有的 map\\n    ThreadLocalMap m = getMap(Thread.currentThread());\\n    if (m != null) {\\n        // 从 map 中清理当前 ThreadLocal 对象关联的键值对\\n        m.remove(this);\\n    }\\n}\\n\")])])]),r(\"p\",[a._v(\"remove 方法的时序图如下所示：\\n\"),r(\"img\",{attrs:{src:\"https://img-blog.csdnimg.cn/20200405150646681.png\",alt:\"\"}})]),a._v(\" \"),r(\"p\",[a._v(\"remove 方法是先获取到当前线程的 ThreadLocalMap，并且调用了它的 remove 方法，从 map 中清理当前 ThreadLocal 对象关联的键值对，这样 value 就可以被 GC 回收了。\\n那么 ThreadLocal 是如何实现线程隔离的呢？\")]),a._v(\" \"),r(\"h3\",{attrs:{id:\"threadlocal的-set-方法\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#threadlocal的-set-方法\"}},[a._v(\"#\")]),a._v(\" ThreadLocal的 set 方法\")]),a._v(\" \"),r(\"p\",[a._v(\"我们先去看下 ThreadLocal 的 set 方法，源码如下：\")]),a._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",[r(\"code\",[a._v(\"/**\\n * 为当前 ThreadLocal 对象关联 value 值\\n *\\n * @param value 要存储在此线程的线程副本的值\\n */\\npublic void set(T value) {\\n    // 返回当前ThreadLocal所在的线程\\n    Thread t = Thread.currentThread();\\n    // 返回当前线程持有的map\\n    ThreadLocalMap map = getMap(t);\\n    if (map != null) {\\n        // 如果 ThreadLocalMap 不为空，则直接存储<ThreadLocal, T>键值对\\n        map.set(this, value);\\n    } else {\\n        // 否则，需要为当前线程初始化 ThreadLocalMap，并存储键值对 <this, firstValue>\\n        createMap(t, value);\\n    }\\n}\\n\")])])]),r(\"p\",[a._v(\"set 方法的作用是把我们想要存储的 value 给保存进去。set 方法的流程主要是：\")]),a._v(\" \"),r(\"ul\",[r(\"li\",[a._v(\"先获取到当前线程的引用\")]),a._v(\" \"),r(\"li\",[a._v(\"利用这个引用来获取到 ThreadLocalMap\")]),a._v(\" \"),r(\"li\",[a._v(\"如果 map 为空，则去创建一个 ThreadLocalMap\")]),a._v(\" \"),r(\"li\",[a._v(\"如果 map 不为空，就利用 ThreadLocalMap 的 set 方法将 value 添加到 map 中\\nset 方法的时序图如下所示：\\n\"),r(\"img\",{attrs:{src:\"https://img-blog.csdnimg.cn/2020040514180914.png\",alt:\"\"}})])]),a._v(\" \"),r(\"p\",[a._v(\"其中 map 就是我们上面讲到的 ThreadLocalMap，可以看到它是通过当前线程对象获取到的 ThreadLocalMap，接下来我们看 getMap方法的源代码：\")]),a._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",[r(\"code\",[a._v(\"/**\\n * 返回当前线程 thread 持有的 ThreadLocalMap\\n *\\n * @param t 当前线程\\n * @return ThreadLocalMap\\n */\\nThreadLocalMap getMap(Thread t) {\\n    return t.threadLocals;\\n}\\n\")])])]),r(\"p\",[a._v(\"getMap 方法的作用主要是获取当前线程内的 ThreadLocalMap 对象，原来这个 ThreadLocalMap 是线程的一个属性，下面让我们看看 Thread 中的相关代码：\")]),a._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",[r(\"code\",[a._v(\"/**\\n * ThreadLocal 的 ThreadLocalMap 是线程的一个属性，所以在多线程环境下 threadLocals 是线程安全的\\n */\\nThreadLocal.ThreadLocalMap threadLocals = null;\\n\")])])]),r(\"p\",[a._v(\"可以看出每个线程都有 ThreadLocalMap 对象，被命名为 threadLocals，默认为 null，所以每个线程的 ThreadLocals 都是隔离独享的。\")]),a._v(\" \"),r(\"p\",[a._v(\"调用 ThreadLocalMap.set() 时，会把当前 threadLocal 对象作为 key，想要保存的对象作为 value，存入 map。\")]),a._v(\" \"),r(\"p\",[a._v(\"其中 ThreadLocalMap.set() 的源码如下：\")]),a._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",[r(\"code\",[a._v(\"/**\\n * 在 map 中存储键值对<key, value>\\n *\\n * @param key   threadLocal\\n * @param value 要设置的 value 值\\n */\\nprivate void set(ThreadLocal<?> key, Object value) {\\n    Entry[] tab = table;\\n    int len = tab.length;\\n    // 计算 key 在数组中的下标\\n    int i = key.threadLocalHashCode & (len - 1);\\n    // 遍历一段连续的元素，以查找匹配的 ThreadLocal 对象\\n    for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) {\\n        // 获取该哈希值处的ThreadLocal对象\\n        ThreadLocal<?> k = e.get();\\n\\n        // 键值ThreadLocal匹配，直接更改map中的value\\n        if (k == key) {\\n            e.value = value;\\n            return;\\n        }\\n\\n        // 若 key 是 null，说明 ThreadLocal 被清理了，直接替换掉\\n        if (k == null) {\\n            replaceStaleEntry(key, value, i);\\n            return;\\n        }\\n    }\\n\\n    // 直到遇见了空槽也没找到匹配的ThreadLocal对象，那么在此空槽处安排ThreadLocal对象和缓存的value\\n    tab[i] = new Entry(key, value);\\n    int sz = ++size;\\n    // 如果没有元素被清理，那么就要检查当前元素数量是否超过了容量阙值(数组大小的三分之二)，以便决定是否扩容\\n    if (!cleanSomeSlots(i, sz) && sz >= threshold) {\\n        // 扩容的过程也是对所有的 key 重新哈希的过程\\n        rehash();\\n    }\\n}\\n\")])])]),r(\"p\",[a._v(\"相信到这里，大家应该对 Thread、ThreadLocal 以及 ThreadLocalMap 的关系有了进一步的理解，下图为三者之间的关系：\\n\"),r(\"img\",{attrs:{src:\"https://img-blog.csdnimg.cn/20200405125741464.png\",alt:\"\"}})]),a._v(\" \"),r(\"h3\",{attrs:{id:\"threadlocal-的-get-方法\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#threadlocal-的-get-方法\"}},[a._v(\"#\")]),a._v(\" ThreadLocal 的 get 方法\")]),a._v(\" \"),r(\"p\",[a._v(\"了解完 set 方法后，让我们看下 get 方法，源码如下：\")]),a._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",[r(\"code\",[a._v('/**\\n * 返回当前 ThreadLocal 对象关联的值\\n *\\n * @return\\n */\\npublic T get() {\\n    // 返回当前 ThreadLocal 所在的线程\\n    Thread t = Thread.currentThread();\\n    // 从线程中拿到 ThreadLocalMap\\n    ThreadLocalMap map = getMap(t);\\n    if (map != null) {\\n        // 从 map 中拿到 entry\\n        ThreadLocalMap.Entry e = map.getEntry(this);\\n        // 如果不为空，读取当前 ThreadLocal 中保存的值\\n        if (e != null) {\\n            @SuppressWarnings(\"unchecked\")\\n            T result = (T) e.value;\\n            return result;\\n        }\\n    }\\n    // 若 map 为空，则对当前线程的 ThreadLocal 进行初始化，最后返回当前的 ThreadLocal 对象关联的初值，即 value\\n    return setInitialValue();\\n}\\n')])])]),r(\"p\",[a._v(\"get 方法的主要流程为：\")]),a._v(\" \"),r(\"ul\",[r(\"li\",[a._v(\"先获取到当前线程的引用\")]),a._v(\" \"),r(\"li\",[a._v(\"获取当前线程内部的 ThreadLocalMap\")]),a._v(\" \"),r(\"li\",[a._v(\"如果 map 存在，则获取当前 ThreadLocal 对应的 value 值\")]),a._v(\" \"),r(\"li\",[a._v(\"如果 map 不存在或者找不到 value 值，则调用 setInitialValue() 进行初始化\\nget 方法的时序图如下所示：\\n\"),r(\"img\",{attrs:{src:\"https://img-blog.csdnimg.cn/20200405141521235.png\",alt:\"\"}})])]),a._v(\" \"),r(\"p\",[a._v(\"其中每个 Thread 的 ThreadLocalMap 以 threadLocal 作为 key，保存自己线程的 value 副本，也就是保存在每个线程中，并没有保存在 ThreadLocal 对象中。\\n其中 ThreadLocalMap.getEntry() 方法的源码如下：\")]),a._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",[r(\"code\",[a._v(\"/**\\n * 返回 key 关联的键值对实体\\n *\\n * @param key threadLocal\\n * @return\\n */\\nprivate Entry getEntry(ThreadLocal<?> key) {\\n    int i = key.threadLocalHashCode & (table.length - 1);\\n    Entry e = table[i];\\n    // 若 e 不为空，并且 e 的 ThreadLocal 的内存地址和 key 相同，直接返回\\n    if (e != null && e.get() == key) {\\n        return e;\\n    } else {\\n        // 从 i 开始向后遍历找到键值对实体\\n        return getEntryAfterMiss(key, i, e);\\n    }\\n}\\n\")])])]),r(\"h3\",{attrs:{id:\"threadlocalmap-的-resize-方法\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#threadlocalmap-的-resize-方法\"}},[a._v(\"#\")]),a._v(\" ThreadLocalMap 的 resize 方法\")]),a._v(\" \"),r(\"p\",[a._v(\"当 ThreadLocalMap 中的 ThreadLocal 的个数超过容量阈值时，ThreadLocalMap 就要开始扩容了，我们一起来看下 resize 的源代码：\")]),a._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",[r(\"code\",[a._v(\"/**\\n * 扩容，重新计算索引，标记垃圾值，方便 GC 回收\\n */\\nprivate void resize() {\\n    Entry[] oldTab = table;\\n    int oldLen = oldTab.length;\\n    int newLen = oldLen * 2;\\n    // 新建一个数组，按照2倍长度扩容\\n    Entry[] newTab = new Entry[newLen];\\n    int count = 0;\\n\\n    // 将旧数组的值拷贝到新数组上\\n    for (int j = 0; j < oldLen; ++j) {\\n        Entry e = oldTab[j];\\n        if (e != null) {\\n            ThreadLocal<?> k = e.get();\\n            // 若有垃圾值，则标记清理该元素的引用，以便GC回收\\n            if (k == null) {\\n                e.value = null;\\n            } else {\\n                // 计算 ThreadLocal 在新数组中的位置\\n                int h = k.threadLocalHashCode & (newLen - 1);\\n                // 如果发生冲突，使用线性探测往后寻找合适的位置\\n                while (newTab[h] != null) {\\n                    h = nextIndex(h, newLen);\\n                }\\n                newTab[h] = e;\\n                count++;\\n            }\\n        }\\n    }\\n    // 设置新的扩容阈值，为数组长度的三分之二\\n    setThreshold(newLen);\\n    size = count;\\n    table = newTab;\\n}\\n\")])])]),r(\"p\",[a._v(\"resize 方法主要是进行扩容，同时会将垃圾值标记方便 GC 回收，扩容后数组大小是原来数组的两倍。\")]),a._v(\" \"),r(\"h3\",{attrs:{id:\"threadlocal-应用场景\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#threadlocal-应用场景\"}},[a._v(\"#\")]),a._v(\" ThreadLocal 应用场景\")]),a._v(\" \"),r(\"p\",[a._v(\"ThreadLocal 的特性也导致了应用场景比较广泛，主要的应用场景如下：\")]),a._v(\" \"),r(\"ul\",[r(\"li\",[a._v(\"线程间数据隔离，各线程的 ThreadLocal 互不影响\")]),a._v(\" \"),r(\"li\",[a._v(\"方便同一个线程使用某一对象，避免不必要的参数传递\")]),a._v(\" \"),r(\"li\",[a._v(\"全链路追踪中的 traceId 或者流程引擎中上下文的传递一般采用 ThreadLocal\")]),a._v(\" \"),r(\"li\",[a._v(\"Spring 事务管理器采用了 ThreadLocal\")]),a._v(\" \"),r(\"li\",[a._v(\"Spring MVC 的 RequestContextHolder 的实现使用了 ThreadLocal\")])]),a._v(\" \"),r(\"h4\",{attrs:{id:\"自己的理解\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#自己的理解\"}},[a._v(\"#\")]),a._v(\" 自己的理解\")]),a._v(\" \"),r(\"p\",[a._v(\"1.首先我们会在类中申明一个成员变量：ThreadLocal\"),r(\"String\",[a._v(' threadLocal = new ThreadLocal<>();\\n2.然后再线程Thread1设置一个值：thread1.set(\"Thread one\"); 这时内部实现是\\n(1)获取当前线程Thread:Thread t = Thread.currentThread();\\n(2)从t中获取到ThreadLocalMap:ThreadLocalMap map = getMap(t); 返回t.threadLocalMaps（Thread的内部成员变量）\\n(3)判断map是否为空，如果为空则创建一个map，如果不为空：则进行map.set(ThreadLocal<?>key, Object value);\\na:把当前对象ThreadLocal的引用作为map的key传入，以及value:\"Thread one\"传入\\nb:调用当前ThreadLocal.netHashCode(key)计算当前key在map中(Map.Entry())的数组位置，找到数组下标table[i]\\nc:如果能找到下标位置i，则将table[i]的值替换为value，如果不能则：table[i] = new Entry[key, value]\\nd:新key的hashCode去找table位置，如果当前数据大于了2/3的容量空间，则需要扩容：reHash()\\n(4)此时，Thread.threadLocalMaps map就设置好了对应的value，这属于线程私有的变量了，基于线程隔离，所以是线程安全的\\n(5)如果此时线程Thread2设置一个值：thread2.set(\"Thread two\"); 将继续走上面逻辑，设置到Thread2线程内部变量中：Thread.threadLocalMaps\\n(6)但是如果当前线程所在类有多个ThreadLocal<?> threadLocal2对象，且又设置了另外一个变量：threadLocal2.set(\"TThread 2\");将设置到当前线程Thread的内部变量threadLocalMaps的value中\\n(7)当前线程t获取数据，也是threadLocal.get();即可拿到线程变量threadLocalMaps中的map的value的值\\n3.当前线程在自己的生命周期:线程栈帧执行完之前，是会一直持有这个对象'),r(\"threadLocal\",[a._v(\"的，在自己生命周期内的get()值都是一样的，且不会被别的线程感知与获取\\n4.当当前线程执行完成，则线程销毁，自己所持有的threadLocal也将被GC回收。\\n5.当当前线程被销毁前，如果一直存在，将可能造成内存泄漏：对象引用一直存在，但是对象已经没有了作用，久而久之将造成OOM(某个对象一直持续堆积内存，但是又可以被回收但没有被回收)\\n此时，是因为线程使用完了threadLocal可以被GC，他的key是weakReference弱引用的，可以被GC，但是Object:value为强引用，被当前线程所持有，线程未被销毁不能被GC\")])],1)],1),a._v(\" \"),r(\"h4\",{attrs:{id:\"threadlocal面试题\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#threadlocal面试题\"}},[a._v(\"#\")]),a._v(\" ThreadLocal面试题\")]),a._v(\" \"),r(\"h5\",{attrs:{id:\"threadlocal会造成内存泄漏\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#threadlocal会造成内存泄漏\"}},[a._v(\"#\")]),a._v(\" ThreadLocal会造成内存泄漏\")]),a._v(\" \"),r(\"p\",[a._v(\"是的，线程所持有的threadLocalMaps是ThreadLocal.ThreadLocalMap<ThreadLocal<?> firstKey, Object firstValue>，内部Entry extends WeakReference<\"),a._v(\"<?>>，所以当\\nset值时，map所持有的Entry<WeakReference<ThreadLocal<?> key, Object value>的key树弱引用的，当线程不销毁或者别卡死时，value的强引用类型将不会GC掉value值\")]),a._v(\" \"),r(\"h5\",{attrs:{id:\"threadlocal如何保证线程安全\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#threadlocal如何保证线程安全\"}},[a._v(\"#\")]),a._v(\" ThreadLocal如何保证线程安全\")]),a._v(\" \"),r(\"p\",[a._v(\"ThreadLocal有一个静态内部类ThreadLocalMap，对ThreadLocal的操作值都会设置到ThreadLocalMap中。同时呢，thread线程类内部也维护了一个ThreadLocal.ThreadLocalMaps变量\\n当我们使用ThreadLocal.set()值时，将获取当前线程t，进而获取其t的threadLocalMaps，在对其进行设置，也就是说最终的值还是到了Thread内部变量中。所谓线程私有，线程间隔离，自然\\n做到了线程安全。\")]),a._v(\" \"),r(\"h4\",{attrs:{id:\"threadlocalmap如何解决hash冲突\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#threadlocalmap如何解决hash冲突\"}},[a._v(\"#\")]),a._v(\" ThreadLocalMap如何解决Hash冲突\")]),a._v(\" \"),r(\"p\",[a._v(\"当一个线程栈中存在很多的ThreadLocal对象时，将都会设置到当前Thread.ThreadLocalMap中，这就涉及到了一个寻址的问题，就是当前threadLocal对象在map的哪个位置。（ThreadLocalMap是\\nThreadLocal的内部静态类，Map的内部结构是Entry<WeakReference\"),r(\"ThreadLocal\",[a._v(\">，新插入的值要找到ThreadLocal在Entry(table[?])中的位置！当然，如果插入的是当前类型的ThreadLocal就不会\\n找nextHashCode，而是去替换值）\\nSet值时：ThreadLocalMap中寻找nextHashCode的方式叫做：开放地址法或者也叫线性探测法。查找过程有点像循环数组，先找到当前ThreadLocal的hashCode，先比对，如果当前有值【此时就是hash冲突了】，\\n则找table的下一个坐标，如果下一个坐标有值则再下一个，如果整个空间都找不到则产生溢出。如果当前值已经set进去了，先清理过期Entry，之后判断当前容量达到了当前容量2/3时做reHash()扩容。\\nps：过期Entry就是变量为空，就是value被清空了。\")])],1),a._v(\" \"),r(\"h4\",{attrs:{id:\"总结\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#总结\"}},[a._v(\"#\")]),a._v(\" 总结\")]),a._v(\" \"),r(\"p\",[a._v(\"本文主要从源码的角度解析了 ThreadLocal，并分析了发生内存泄漏的原因，最后对它的应用场景进行了简单介绍。\\n欢迎留言交流讨论，原创不易，觉得文章不错，请在看转发支持一下。\\n更详细的源码解析可以点击链接查看：https://github.com/wupeixuan/JDKSourceCode1.8\")]),a._v(\" \"),r(\"blockquote\",[r(\"p\",[a._v(\"参考\\n《Java并发编程实战》\\nhttps://www.javaspecialists.eu/archive/Issue164.html\\nhttps://mp.weixin.qq.com/s/vURwBPgVuv4yGT1PeEHxZQ\\nJava并发编程学习宝典\\n面试官系统精讲Java源码及大厂真题\\nJava 并发面试 78 讲\")])])])}),[],!1,null,null,null);e.default=t.exports}}]);","extractedComments":[]}