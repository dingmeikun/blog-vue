<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>ThreadLocal源码分析 | TIm&#39;s blog</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/blog/favicon.ico">
    <link rel="manifest" href="/blog/img/tim.jpg">
    <link rel="apple-touch-icon" href="/blog/img/tim.jpg">
    <meta name="description" content="蒂姆的个人博客">
    <meta http-quiv="pragma" cotent="no-cache">
    <meta http-quiv="pragma" cotent="no-cache,must-revalidate">
    <meta http-quiv="expires" cotent="0">
    
    <link rel="preload" href="/blog/assets/css/0.styles.1275376d.css" as="style"><link rel="preload" href="/blog/assets/js/app.ee1ac8a5.js" as="script"><link rel="preload" href="/blog/assets/js/3.95ba7ff8.js" as="script"><link rel="preload" href="/blog/assets/js/1.4e5d9018.js" as="script"><link rel="preload" href="/blog/assets/js/19.5bcf830e.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.67a1d07b.js"><link rel="prefetch" href="/blog/assets/js/11.e1ee17ca.js"><link rel="prefetch" href="/blog/assets/js/12.c6db7e68.js"><link rel="prefetch" href="/blog/assets/js/13.3532a141.js"><link rel="prefetch" href="/blog/assets/js/14.b9b1200c.js"><link rel="prefetch" href="/blog/assets/js/15.be0b5962.js"><link rel="prefetch" href="/blog/assets/js/16.32ffd37d.js"><link rel="prefetch" href="/blog/assets/js/17.3e7842dd.js"><link rel="prefetch" href="/blog/assets/js/18.5d69f2bc.js"><link rel="prefetch" href="/blog/assets/js/4.25481aef.js"><link rel="prefetch" href="/blog/assets/js/5.4a05cd2c.js"><link rel="prefetch" href="/blog/assets/js/6.7b0e1376.js"><link rel="prefetch" href="/blog/assets/js/7.259f140a.js"><link rel="prefetch" href="/blog/assets/js/8.b358f5e0.js"><link rel="prefetch" href="/blog/assets/js/9.1d9c0971.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.1275376d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-130b300a><div data-v-130b300a><div class="password-shadow password-wrapper-out" style="display:none;" data-v-25ba6db2 data-v-130b300a data-v-130b300a><h3 class="title" data-v-25ba6db2 data-v-25ba6db2>TIm's blog</h3> <p class="description" data-v-25ba6db2 data-v-25ba6db2>蒂姆的个人博客</p> <label id="box" class="inputBox" data-v-25ba6db2 data-v-25ba6db2><input type="password" value="" data-v-25ba6db2> <span data-v-25ba6db2>Konck! Knock!</span> <button data-v-25ba6db2>OK</button></label> <div class="footer" data-v-25ba6db2 data-v-25ba6db2><span data-v-25ba6db2><i class="iconfont reco-theme" data-v-25ba6db2></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-25ba6db2>vuePress-theme-reco</a></span> <span data-v-25ba6db2><i class="iconfont reco-copyright" data-v-25ba6db2></i> <a data-v-25ba6db2><!---->
            
          <!---->
          2022
        </a></span></div></div> <div class="hide" data-v-130b300a><header class="navbar" data-v-130b300a><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/img/tim.jpg" alt="TIm's blog" class="logo"> <span class="site-name">TIm's blog</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link"><i class="undefined"></i>
  主页
</a></div><div class="nav-item"><a href="/blog/java/" class="nav-link router-link-active"><i class="undefined"></i>
  java基础
</a></div><div class="nav-item"><a href="/blog/architecture/" class="nav-link"><i class="undefined"></i>
  架构
</a></div><div class="nav-item"><a href="/blog/database/" class="nav-link"><i class="undefined"></i>
  数据库
</a></div><div class="nav-item"><a href="/blog/algorithm/" class="nav-link"><i class="undefined"></i>
  算法
</a></div><div class="nav-item"><a href="/blog/interview/" class="nav-link"><i class="undefined"></i>
  面试
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      蒂姆的个人博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/dingmeikun" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="/blog/gongzhonghao.html" class="nav-link"><i class="undefined"></i>
  公众号
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-130b300a></div> <aside class="sidebar" data-v-130b300a><div class="personal-info-wrapper" data-v-39576ba9 data-v-130b300a><!----> <!----> <div class="num" data-v-39576ba9><div data-v-39576ba9><h3 data-v-39576ba9>8</h3> <h6 data-v-39576ba9>文章</h6></div> <div data-v-39576ba9><h3 data-v-39576ba9>0</h3> <h6 data-v-39576ba9>标签</h6></div></div> <ul class="social-links" data-v-39576ba9></ul> <hr data-v-39576ba9></div> <nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link"><i class="undefined"></i>
  主页
</a></div><div class="nav-item"><a href="/blog/java/" class="nav-link router-link-active"><i class="undefined"></i>
  java基础
</a></div><div class="nav-item"><a href="/blog/architecture/" class="nav-link"><i class="undefined"></i>
  架构
</a></div><div class="nav-item"><a href="/blog/database/" class="nav-link"><i class="undefined"></i>
  数据库
</a></div><div class="nav-item"><a href="/blog/algorithm/" class="nav-link"><i class="undefined"></i>
  算法
</a></div><div class="nav-item"><a href="/blog/interview/" class="nav-link"><i class="undefined"></i>
  面试
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      蒂姆的个人博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/dingmeikun" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="/blog/gongzhonghao.html" class="nav-link"><i class="undefined"></i>
  公众号
</a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/blog/java/README" class="sidebar-heading clickable open"><span>基础学习</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/java/MyBtis-Plus的流式查询.html" class="sidebar-link">MyBtis-Plus的流式查询</a></li><li><a href="/blog/java/MySQL前缀索引选择性.html" class="sidebar-link">MySQL前缀索引选择性</a></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-25ba6db2 data-v-130b300a><h3 class="title" data-v-25ba6db2 data-v-25ba6db2></h3> <!----> <label id="box" class="inputBox" data-v-25ba6db2 data-v-25ba6db2><input type="password" value="" data-v-25ba6db2> <span data-v-25ba6db2>Konck! Knock!</span> <button data-v-25ba6db2>OK</button></label> <div class="footer" data-v-25ba6db2 data-v-25ba6db2><span data-v-25ba6db2><i class="iconfont reco-theme" data-v-25ba6db2></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-25ba6db2>vuePress-theme-reco</a></span> <span data-v-25ba6db2><i class="iconfont reco-copyright" data-v-25ba6db2></i> <a data-v-25ba6db2><!---->
            
          <!---->
          2022
        </a></span></div></div> <div data-v-130b300a><main class="page"><section><div class="page-title"><h1 class="title">ThreadLocal源码分析</h1> <div data-v-f875f3fc><!----> <!----> <!----> <!----></div></div> <div class="theme-reco-content content__default"><h2 id="threadlocal源码分析"><a href="#threadlocal源码分析" class="header-anchor">#</a> ThreadLocal源码分析</h2> <p>当多线程访问共享可变数据时，涉及到线程间同步的问题，并不是所有时候，都要用到共享数据，所以就需要线程封闭出场了。</p> <p>数据都被封闭在各自的线程之中，就不需要同步，这种通过将数据封闭在线程中而避免使用同步的技术称为线程封闭。</p> <p>本文主要介绍线程封闭中的其中一种体现：ThreadLocal，将会介绍什么是 ThreadLocal；从 ThreadLocal 源码角度分析，最后介绍 ThreadLocal 的应用场景。</p> <h3 id="什么是-threadlocal"><a href="#什么是-threadlocal" class="header-anchor">#</a> 什么是 ThreadLocal？</h3> <p>ThreadLocal 是 Java 里一种特殊变量，它是一个线程级别变量，每个线程都有一个 ThreadLocal 就是每个线程都拥有了自己独立的一个变量，竞态条件被彻底消除了，在并发模式下是绝对安全的变量。</p> <p>可以通过 ThreadLocal<T> value = new ThreadLocal<T>(); 来使用。</T></T></p> <p>会自动在每一个线程上创建一个 T 的副本，副本之间彼此独立，互不影响，可以用 ThreadLocal 存储一些参数，以便在线程中多个方法中使用，用以代替方法传参的做法。</p> <p>下面通过例子来了解下 ThreadLocal：</p> <div class="language- extra-class"><pre><code>public class ThreadLocalDemo {
    /**
     * ThreadLocal变量，每个线程都有一个副本，互不干扰
     */
    public static final ThreadLocal&lt;String&gt; THREAD_LOCAL = new ThreadLocal&lt;&gt;();

    public static void main(String[] args) throws Exception {
        new ThreadLocalDemo().threadLocalTest();
    }

    public void threadLocalTest() throws Exception {
        // 主线程设置值
        THREAD_LOCAL.set(&quot;wupx&quot;);
        String v = THREAD_LOCAL.get();
        System.out.println(&quot;Thread-0线程执行之前，&quot; + Thread.currentThread().getName() + &quot;线程取到的值：&quot; + v);

        new Thread(new Runnable() {
            @Override
            public void run() {
                String v = THREAD_LOCAL.get();
                System.out.println(Thread.currentThread().getName() + &quot;线程取到的值：&quot; + v);
                // 设置 threadLocal
                THREAD_LOCAL.set(&quot;huxy&quot;);
                v = THREAD_LOCAL.get();
                System.out.println(&quot;重新设置之后，&quot; + Thread.currentThread().getName() + &quot;线程取到的值为：&quot; + v);
                System.out.println(Thread.currentThread().getName() + &quot;线程执行结束&quot;);
            }
        }).start();
        // 等待所有线程执行结束
        Thread.sleep(3000L);
        v = THREAD_LOCAL.get();
        System.out.println(&quot;Thread-0线程执行之后，&quot; + Thread.currentThread().getName() + &quot;线程取到的值：&quot; + v);
    }
}
</code></pre></div><p>首先通过 static final 定义了一个 THREAD_LOCAL 变量，其中 static 是为了确保全局只有一个保存 String 对象的 ThreadLocal 实例；final 确保 ThreadLocal 的实例不可更改，防止被意外改变，导致放入的值和取出来的不一致，另外还能防止 ThreadLocal 的内存泄漏。上面的例子是演示在不同的线程中获取它会得到不同的结果，运行结果如下：</p> <div class="language- extra-class"><pre><code>Thread-0线程执行之前，main线程取到的值：wupx
Thread-0线程取到的值：null
重新设置之后Thread-0线程取到的值为：huxy
Thread-0线程执行结束
Thread-0线程执行之后，main线程取到的值：wupx
首先在 Thread-0 线程执行之前，先给 THREAD_LOCAL 设置为 wupx，然后可以取到这个值，然后通过创建一个新的线程以后去取这个值，发现新线程取到的为 null，意外着这个变量在不同线程中取到的值是不同的，不同线程之间对于 ThreadLocal 会有对应的副本，接着在线程 Thread-0 中执行对 THREAD_LOCAL 的修改，将值改为 huxy，可以发现线程 Thread-0 获取的值变为了 huxy，主线程依然会读取到属于它的副本数据 wupx，这就是线程的封闭。
</code></pre></div><p>看到这里，我相信大家一定会好奇 ThreadLocal 是如何做到多个线程对同一对象 set 操作，但是 get 获取的值还都是每个线程 set 的值呢，接下来就让我们进入源码解析环节：</p> <h3 id="threadlocal-源码解析"><a href="#threadlocal-源码解析" class="header-anchor">#</a> ThreadLocal 源码解析</h3> <p>首先看下 ThreadLocal 都有哪些重要属性：</p> <div class="language- extra-class"><pre><code>// 当前 ThreadLocal 的 hashCode，由 nextHashCode() 计算而来，用于计算当前 ThreadLocal 在 ThreadLocalMap 中的索引位置
private final int threadLocalHashCode = nextHashCode();

// 哈希魔数，主要与斐波那契散列法以及黄金分割有关
private static final int HASH_INCREMENT = 0x61c88647;

// 返回计算出的下一个哈希值，其值为 i * HASH_INCREMENT，其中 i 代表调用次数
private static int nextHashCode() {
    return nextHashCode.getAndAdd(HASH_INCREMENT);
}

// 保证了在一台机器中每个 ThreadLocal 的 threadLocalHashCode 是唯一的
private static AtomicInteger nextHashCode = new AtomicInteger();
</code></pre></div><p>其中的 HASH_INCREMENT 也不是随便取的，它转化为十进制是 1640531527，2654435769 转换成 int 类型就是 -1640531527，2654435769 等于 (√5-1)/2 乘以 2 的 32 次方。(√5-1)/2 就是黄金分割数，近似为 0.618，也就是说 0x61c88647 理解为一个黄金分割数乘以 2 的 32 次方，它可以保证 nextHashCode 生成的哈希值，均匀的分布在 2 的幂次方上，且小于 2 的 32 次方。
下面是 javaspecialists 中一篇文章对它的介绍：</p> <blockquote><p>This number represents the golden ratio (sqrt(5)-1) times two to the power of 31 ((sqrt(5)-1) * (2^31)). The result is then a golden number, either 2654435769 or -1640531527.</p></blockquote> <p>下面用例子来证明下：</p> <div class="language- extra-class"><pre><code>private static final int HASH_INCREMENT = 0x61c88647;

public static void main(String[] args) throws Exception {
    int n = 5;
    int max = 2 &lt;&lt; (n - 1);
    for (int i = 0; i &lt; max; i++) {
        System.out.print(i * HASH_INCREMENT &amp; (max - 1));
        System.out.print(&quot; &quot;);

    }
}
</code></pre></div><p>运行结果为：<code>0 7 14 21 28 3 10 17 24 31 6 13 20 27 2 9 16 23 30 5 12 19 26 1 8 15 22 29 4 11 18 25</code>
可以发现元素索引值完美的散列在数组当中，并没有出现冲突。</p> <h3 id="threadlocalmap"><a href="#threadlocalmap" class="header-anchor">#</a> ThreadLocalMap</h3> <p>除了上述属性外，还有一个重要的属性 ThreadLocalMap，ThreadLocalMap 是 ThreadLocal 的静态内部类，当一个线程有多个 ThreadLocal 时，需要一个容器来管理多个 ThreadLocal，ThreadLocalMap 的作用就是管理线程中多个 ThreadLocal，源码如下：</p> <div class="language- extra-class"><pre><code>static class ThreadLocalMap {
    /**
     * 键值对实体的存储结构
     * 
     * ThreadLocalMap内部维护了一个Entry数组，Key为ThreadLocal的引用指向ThreadLocal，Value为ThreadLocal中设置的值
     * ThreadLocalMap是ThreadLocal的一个静态内部类，对Threadlocal的操作都会到ThreadLocalMap中实现
     * Thread内部也维护了一个ThreadLocals成员变量，指向ThreadLocal.ThreadLocalMap
     */
    static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {
        // 当前线程关联的 value，这个 value 并没有用弱引用追踪
        Object value;

        /**
         * 构造键值对
         *
         * @param k k 作 key,作为 key 的 ThreadLocal 会被包装为一个弱引用
         * @param v v 作 value
         */
        Entry(ThreadLocal&lt;?&gt; k, Object v) {
            super(k);
            value = v;
        }
    }

    // 初始容量，必须为 2 的幂
    private static final int INITIAL_CAPACITY = 16;

    // 存储 ThreadLocal 的键值对实体数组，长度必须为 2 的幂
    private Entry[] table;

    // ThreadLocalMap 元素数量
    private int size = 0;

    // 扩容的阈值，默认是数组大小的三分之二
    private int threshold;
}
</code></pre></div><p>从源码中看到 ThreadLocalMap 其实就是一个简单的 Map 结构，底层是数组，有初始化大小，也有扩容阈值大小，数组的元素是 Entry，Entry 的 key 就是 ThreadLocal 的引用，value 是 ThreadLocal 的值。ThreadLocalMap 解决 hash 冲突的方式采用的是线性探测法，如果发生冲突会继续寻找下一个空的位置。
这样的就有可能会发生内存泄漏的问题，下面让我们进行分析!</p> <h3 id="threadlocal-内存泄漏"><a href="#threadlocal-内存泄漏" class="header-anchor">#</a> ThreadLocal 内存泄漏#</h3> <p>ThreadLocal 在没有外部强引用时，发生 GC 时会被回收，那么 ThreadLocalMap 中保存的 key 值就变成了 null，而 Entry 又被 threadLocalMap 对象引用，threadLocalMap 对象又被 Thread 对象所引用，那么当 Thread 一直不终结的话，value 对象就会一直存在于内存中，也就导致了内存泄漏，直至 Thread 被销毁后，才会被回收。
那么如何避免内存泄漏呢？
在使用完 ThreadLocal 变量后，需要我们手动 remove 掉，防止 ThreadLocalMap 中 Entry 一直保持对 value 的强引用，导致 value 不能被回收，其中 remove 源码如下所示：</p> <div class="language- extra-class"><pre><code>/**
 * 清理当前 ThreadLocal 对象关联的键值对
 */
public void remove() {
    // 返回当前线程持有的 map
    ThreadLocalMap m = getMap(Thread.currentThread());
    if (m != null) {
        // 从 map 中清理当前 ThreadLocal 对象关联的键值对
        m.remove(this);
    }
}
</code></pre></div><p>remove 方法的时序图如下所示：
<img src="https://img-blog.csdnimg.cn/20200405150646681.png" alt=""></p> <p>remove 方法是先获取到当前线程的 ThreadLocalMap，并且调用了它的 remove 方法，从 map 中清理当前 ThreadLocal 对象关联的键值对，这样 value 就可以被 GC 回收了。
那么 ThreadLocal 是如何实现线程隔离的呢？</p> <h3 id="threadlocal的-set-方法"><a href="#threadlocal的-set-方法" class="header-anchor">#</a> ThreadLocal的 set 方法</h3> <p>我们先去看下 ThreadLocal 的 set 方法，源码如下：</p> <div class="language- extra-class"><pre><code>/**
 * 为当前 ThreadLocal 对象关联 value 值
 *
 * @param value 要存储在此线程的线程副本的值
 */
public void set(T value) {
    // 返回当前ThreadLocal所在的线程
    Thread t = Thread.currentThread();
    // 返回当前线程持有的map
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        // 如果 ThreadLocalMap 不为空，则直接存储&lt;ThreadLocal, T&gt;键值对
        map.set(this, value);
    } else {
        // 否则，需要为当前线程初始化 ThreadLocalMap，并存储键值对 &lt;this, firstValue&gt;
        createMap(t, value);
    }
}
</code></pre></div><p>set 方法的作用是把我们想要存储的 value 给保存进去。set 方法的流程主要是：</p> <ul><li>先获取到当前线程的引用</li> <li>利用这个引用来获取到 ThreadLocalMap</li> <li>如果 map 为空，则去创建一个 ThreadLocalMap</li> <li>如果 map 不为空，就利用 ThreadLocalMap 的 set 方法将 value 添加到 map 中
set 方法的时序图如下所示：
<img src="https://img-blog.csdnimg.cn/2020040514180914.png" alt=""></li></ul> <p>其中 map 就是我们上面讲到的 ThreadLocalMap，可以看到它是通过当前线程对象获取到的 ThreadLocalMap，接下来我们看 getMap方法的源代码：</p> <div class="language- extra-class"><pre><code>/**
 * 返回当前线程 thread 持有的 ThreadLocalMap
 *
 * @param t 当前线程
 * @return ThreadLocalMap
 */
ThreadLocalMap getMap(Thread t) {
    return t.threadLocals;
}
</code></pre></div><p>getMap 方法的作用主要是获取当前线程内的 ThreadLocalMap 对象，原来这个 ThreadLocalMap 是线程的一个属性，下面让我们看看 Thread 中的相关代码：</p> <div class="language- extra-class"><pre><code>/**
 * ThreadLocal 的 ThreadLocalMap 是线程的一个属性，所以在多线程环境下 threadLocals 是线程安全的
 */
ThreadLocal.ThreadLocalMap threadLocals = null;
</code></pre></div><p>可以看出每个线程都有 ThreadLocalMap 对象，被命名为 threadLocals，默认为 null，所以每个线程的 ThreadLocals 都是隔离独享的。</p> <p>调用 ThreadLocalMap.set() 时，会把当前 threadLocal 对象作为 key，想要保存的对象作为 value，存入 map。</p> <p>其中 ThreadLocalMap.set() 的源码如下：</p> <div class="language- extra-class"><pre><code>/**
 * 在 map 中存储键值对&lt;key, value&gt;
 *
 * @param key   threadLocal
 * @param value 要设置的 value 值
 */
private void set(ThreadLocal&lt;?&gt; key, Object value) {
    Entry[] tab = table;
    int len = tab.length;
    // 计算 key 在数组中的下标
    int i = key.threadLocalHashCode &amp; (len - 1);
    // 遍历一段连续的元素，以查找匹配的 ThreadLocal 对象
    for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) {
        // 获取该哈希值处的ThreadLocal对象
        ThreadLocal&lt;?&gt; k = e.get();

        // 键值ThreadLocal匹配，直接更改map中的value
        if (k == key) {
            e.value = value;
            return;
        }

        // 若 key 是 null，说明 ThreadLocal 被清理了，直接替换掉
        if (k == null) {
            replaceStaleEntry(key, value, i);
            return;
        }
    }

    // 直到遇见了空槽也没找到匹配的ThreadLocal对象，那么在此空槽处安排ThreadLocal对象和缓存的value
    tab[i] = new Entry(key, value);
    int sz = ++size;
    // 如果没有元素被清理，那么就要检查当前元素数量是否超过了容量阙值(数组大小的三分之二)，以便决定是否扩容
    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) {
        // 扩容的过程也是对所有的 key 重新哈希的过程
        rehash();
    }
}
</code></pre></div><p>相信到这里，大家应该对 Thread、ThreadLocal 以及 ThreadLocalMap 的关系有了进一步的理解，下图为三者之间的关系：
<img src="https://img-blog.csdnimg.cn/20200405125741464.png" alt=""></p> <h3 id="threadlocal-的-get-方法"><a href="#threadlocal-的-get-方法" class="header-anchor">#</a> ThreadLocal 的 get 方法</h3> <p>了解完 set 方法后，让我们看下 get 方法，源码如下：</p> <div class="language- extra-class"><pre><code>/**
 * 返回当前 ThreadLocal 对象关联的值
 *
 * @return
 */
public T get() {
    // 返回当前 ThreadLocal 所在的线程
    Thread t = Thread.currentThread();
    // 从线程中拿到 ThreadLocalMap
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        // 从 map 中拿到 entry
        ThreadLocalMap.Entry e = map.getEntry(this);
        // 如果不为空，读取当前 ThreadLocal 中保存的值
        if (e != null) {
            @SuppressWarnings(&quot;unchecked&quot;)
            T result = (T) e.value;
            return result;
        }
    }
    // 若 map 为空，则对当前线程的 ThreadLocal 进行初始化，最后返回当前的 ThreadLocal 对象关联的初值，即 value
    return setInitialValue();
}
</code></pre></div><p>get 方法的主要流程为：</p> <ul><li>先获取到当前线程的引用</li> <li>获取当前线程内部的 ThreadLocalMap</li> <li>如果 map 存在，则获取当前 ThreadLocal 对应的 value 值</li> <li>如果 map 不存在或者找不到 value 值，则调用 setInitialValue() 进行初始化
get 方法的时序图如下所示：
<img src="https://img-blog.csdnimg.cn/20200405141521235.png" alt=""></li></ul> <p>其中每个 Thread 的 ThreadLocalMap 以 threadLocal 作为 key，保存自己线程的 value 副本，也就是保存在每个线程中，并没有保存在 ThreadLocal 对象中。
其中 ThreadLocalMap.getEntry() 方法的源码如下：</p> <div class="language- extra-class"><pre><code>/**
 * 返回 key 关联的键值对实体
 *
 * @param key threadLocal
 * @return
 */
private Entry getEntry(ThreadLocal&lt;?&gt; key) {
    int i = key.threadLocalHashCode &amp; (table.length - 1);
    Entry e = table[i];
    // 若 e 不为空，并且 e 的 ThreadLocal 的内存地址和 key 相同，直接返回
    if (e != null &amp;&amp; e.get() == key) {
        return e;
    } else {
        // 从 i 开始向后遍历找到键值对实体
        return getEntryAfterMiss(key, i, e);
    }
}
</code></pre></div><h3 id="threadlocalmap-的-resize-方法"><a href="#threadlocalmap-的-resize-方法" class="header-anchor">#</a> ThreadLocalMap 的 resize 方法</h3> <p>当 ThreadLocalMap 中的 ThreadLocal 的个数超过容量阈值时，ThreadLocalMap 就要开始扩容了，我们一起来看下 resize 的源代码：</p> <div class="language- extra-class"><pre><code>/**
 * 扩容，重新计算索引，标记垃圾值，方便 GC 回收
 */
private void resize() {
    Entry[] oldTab = table;
    int oldLen = oldTab.length;
    int newLen = oldLen * 2;
    // 新建一个数组，按照2倍长度扩容
    Entry[] newTab = new Entry[newLen];
    int count = 0;

    // 将旧数组的值拷贝到新数组上
    for (int j = 0; j &lt; oldLen; ++j) {
        Entry e = oldTab[j];
        if (e != null) {
            ThreadLocal&lt;?&gt; k = e.get();
            // 若有垃圾值，则标记清理该元素的引用，以便GC回收
            if (k == null) {
                e.value = null;
            } else {
                // 计算 ThreadLocal 在新数组中的位置
                int h = k.threadLocalHashCode &amp; (newLen - 1);
                // 如果发生冲突，使用线性探测往后寻找合适的位置
                while (newTab[h] != null) {
                    h = nextIndex(h, newLen);
                }
                newTab[h] = e;
                count++;
            }
        }
    }
    // 设置新的扩容阈值，为数组长度的三分之二
    setThreshold(newLen);
    size = count;
    table = newTab;
}
</code></pre></div><p>resize 方法主要是进行扩容，同时会将垃圾值标记方便 GC 回收，扩容后数组大小是原来数组的两倍。</p> <h3 id="threadlocal-应用场景"><a href="#threadlocal-应用场景" class="header-anchor">#</a> ThreadLocal 应用场景</h3> <p>ThreadLocal 的特性也导致了应用场景比较广泛，主要的应用场景如下：</p> <ul><li>线程间数据隔离，各线程的 ThreadLocal 互不影响</li> <li>方便同一个线程使用某一对象，避免不必要的参数传递</li> <li>全链路追踪中的 traceId 或者流程引擎中上下文的传递一般采用 ThreadLocal</li> <li>Spring 事务管理器采用了 ThreadLocal</li> <li>Spring MVC 的 RequestContextHolder 的实现使用了 ThreadLocal</li></ul> <h4 id="自己的理解"><a href="#自己的理解" class="header-anchor">#</a> 自己的理解</h4> <p>1.首先我们会在类中申明一个成员变量：ThreadLocal<String> threadLocal = new ThreadLocal&lt;&gt;();
2.然后再线程Thread1设置一个值：thread1.set(&quot;Thread one&quot;); 这时内部实现是
(1)获取当前线程Thread:Thread t = Thread.currentThread();
(2)从t中获取到ThreadLocalMap:ThreadLocalMap map = getMap(t); 返回t.threadLocalMaps（Thread的内部成员变量）
(3)判断map是否为空，如果为空则创建一个map，如果不为空：则进行map.set(ThreadLocal&lt;?&gt;key, Object value);
a:把当前对象ThreadLocal的引用作为map的key传入，以及value:&quot;Thread one&quot;传入
b:调用当前ThreadLocal.netHashCode(key)计算当前key在map中(Map.Entry())的数组位置，找到数组下标table[i]
c:如果能找到下标位置i，则将table[i]的值替换为value，如果不能则：table[i] = new Entry[key, value]
d:新key的hashCode去找table位置，如果当前数据大于了2/3的容量空间，则需要扩容：reHash()
(4)此时，Thread.threadLocalMaps map就设置好了对应的value，这属于线程私有的变量了，基于线程隔离，所以是线程安全的
(5)如果此时线程Thread2设置一个值：thread2.set(&quot;Thread two&quot;); 将继续走上面逻辑，设置到Thread2线程内部变量中：Thread.threadLocalMaps
(6)但是如果当前线程所在类有多个ThreadLocal&lt;?&gt; threadLocal2对象，且又设置了另外一个变量：threadLocal2.set(&quot;TThread 2&quot;);将设置到当前线程Thread的内部变量threadLocalMaps的value中
(7)当前线程t获取数据，也是threadLocal.get();即可拿到线程变量threadLocalMaps中的map的value的值
3.当前线程在自己的生命周期:线程栈帧执行完之前，是会一直持有这个对象<threadLocal>的，在自己生命周期内的get()值都是一样的，且不会被别的线程感知与获取
4.当当前线程执行完成，则线程销毁，自己所持有的threadLocal也将被GC回收。
5.当当前线程被销毁前，如果一直存在，将可能造成内存泄漏：对象引用一直存在，但是对象已经没有了作用，久而久之将造成OOM(某个对象一直持续堆积内存，但是又可以被回收但没有被回收)
此时，是因为线程使用完了threadLocal可以被GC，他的key是weakReference弱引用的，可以被GC，但是Object:value为强引用，被当前线程所持有，线程未被销毁不能被GC</threadLocal></String></p> <h4 id="threadlocal面试题"><a href="#threadlocal面试题" class="header-anchor">#</a> ThreadLocal面试题</h4> <h5 id="threadlocal会造成内存泄漏"><a href="#threadlocal会造成内存泄漏" class="header-anchor">#</a> ThreadLocal会造成内存泄漏</h5> <p>是的，线程所持有的threadLocalMaps是ThreadLocal.ThreadLocalMap&lt;ThreadLocal&lt;?&gt; firstKey, Object firstValue&gt;，内部Entry extends WeakReference&lt;&lt;?&gt;&gt;，所以当
set值时，map所持有的Entry&lt;WeakReference&lt;ThreadLocal&lt;?&gt; key, Object value&gt;的key树弱引用的，当线程不销毁或者别卡死时，value的强引用类型将不会GC掉value值</p> <h5 id="threadlocal如何保证线程安全"><a href="#threadlocal如何保证线程安全" class="header-anchor">#</a> ThreadLocal如何保证线程安全</h5> <p>ThreadLocal有一个静态内部类ThreadLocalMap，对ThreadLocal的操作值都会设置到ThreadLocalMap中。同时呢，thread线程类内部也维护了一个ThreadLocal.ThreadLocalMaps变量
当我们使用ThreadLocal.set()值时，将获取当前线程t，进而获取其t的threadLocalMaps，在对其进行设置，也就是说最终的值还是到了Thread内部变量中。所谓线程私有，线程间隔离，自然
做到了线程安全。</p> <h4 id="threadlocalmap如何解决hash冲突"><a href="#threadlocalmap如何解决hash冲突" class="header-anchor">#</a> ThreadLocalMap如何解决Hash冲突</h4> <p>当一个线程栈中存在很多的ThreadLocal对象时，将都会设置到当前Thread.ThreadLocalMap中，这就涉及到了一个寻址的问题，就是当前threadLocal对象在map的哪个位置。（ThreadLocalMap是
ThreadLocal的内部静态类，Map的内部结构是Entry&lt;WeakReference<ThreadLocal>&gt;，新插入的值要找到ThreadLocal在Entry(table[?])中的位置！当然，如果插入的是当前类型的ThreadLocal就不会
找nextHashCode，而是去替换值）
Set值时：ThreadLocalMap中寻找nextHashCode的方式叫做：开放地址法或者也叫线性探测法。查找过程有点像循环数组，先找到当前ThreadLocal的hashCode，先比对，如果当前有值【此时就是hash冲突了】，
则找table的下一个坐标，如果下一个坐标有值则再下一个，如果整个空间都找不到则产生溢出。如果当前值已经set进去了，先清理过期Entry，之后判断当前容量达到了当前容量2/3时做reHash()扩容。
ps：过期Entry就是变量为空，就是value被清空了。</ThreadLocal></p> <h4 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h4> <p>本文主要从源码的角度解析了 ThreadLocal，并分析了发生内存泄漏的原因，最后对它的应用场景进行了简单介绍。
欢迎留言交流讨论，原创不易，觉得文章不错，请在看转发支持一下。
更详细的源码解析可以点击链接查看：https://github.com/wupeixuan/JDKSourceCode1.8</p> <blockquote><p>参考
《Java并发编程实战》
https://www.javaspecialists.eu/archive/Issue164.html
https://mp.weixin.qq.com/s/vURwBPgVuv4yGT1PeEHxZQ
Java并发编程学习宝典
面试官系统精讲Java源码及大厂真题
Java 并发面试 78 讲</p></blockquote></div></section> <footer class="page-edit"><!----> <!----></footer> <!----> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:12rem;" data-v-cb1513f6><li class="level-2" data-v-cb1513f6><a href="/blog/java/ThreadLocal%E5%88%86%E6%9E%90.html#threadlocal源码分析" class="sidebar-link reco-side-threadlocal源码分析" data-v-cb1513f6>ThreadLocal源码分析</a></li><li class="level-3" data-v-cb1513f6><a href="/blog/java/ThreadLocal%E5%88%86%E6%9E%90.html#什么是-threadlocal" class="sidebar-link reco-side-什么是-threadlocal" data-v-cb1513f6>什么是 ThreadLocal？</a></li><li class="level-3" data-v-cb1513f6><a href="/blog/java/ThreadLocal%E5%88%86%E6%9E%90.html#threadlocal-源码解析" class="sidebar-link reco-side-threadlocal-源码解析" data-v-cb1513f6>ThreadLocal 源码解析</a></li><li class="level-3" data-v-cb1513f6><a href="/blog/java/ThreadLocal%E5%88%86%E6%9E%90.html#threadlocalmap" class="sidebar-link reco-side-threadlocalmap" data-v-cb1513f6>ThreadLocalMap</a></li><li class="level-3" data-v-cb1513f6><a href="/blog/java/ThreadLocal%E5%88%86%E6%9E%90.html#threadlocal-内存泄漏" class="sidebar-link reco-side-threadlocal-内存泄漏" data-v-cb1513f6>ThreadLocal 内存泄漏#</a></li><li class="level-3" data-v-cb1513f6><a href="/blog/java/ThreadLocal%E5%88%86%E6%9E%90.html#threadlocal的-set-方法" class="sidebar-link reco-side-threadlocal的-set-方法" data-v-cb1513f6>ThreadLocal的 set 方法</a></li><li class="level-3" data-v-cb1513f6><a href="/blog/java/ThreadLocal%E5%88%86%E6%9E%90.html#threadlocal-的-get-方法" class="sidebar-link reco-side-threadlocal-的-get-方法" data-v-cb1513f6>ThreadLocal 的 get 方法</a></li><li class="level-3" data-v-cb1513f6><a href="/blog/java/ThreadLocal%E5%88%86%E6%9E%90.html#threadlocalmap-的-resize-方法" class="sidebar-link reco-side-threadlocalmap-的-resize-方法" data-v-cb1513f6>ThreadLocalMap 的 resize 方法</a></li><li class="level-3" data-v-cb1513f6><a href="/blog/java/ThreadLocal%E5%88%86%E6%9E%90.html#threadlocal-应用场景" class="sidebar-link reco-side-threadlocal-应用场景" data-v-cb1513f6>ThreadLocal 应用场景</a></li></ul></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/blog/assets/js/app.ee1ac8a5.js" defer></script><script src="/blog/assets/js/3.95ba7ff8.js" defer></script><script src="/blog/assets/js/1.4e5d9018.js" defer></script><script src="/blog/assets/js/19.5bcf830e.js" defer></script>
  </body>
</html>
